// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using DBD_Magic.Responses;
//
//    var characterInfoResponse = CharacterInfoResponse.FromJson(jsonString);

namespace DBD_Magic.Responses
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class CharacterInfoResponse
    {
        [JsonProperty("characterIndex")]
        public long CharacterIndex { get; set; }

        [JsonProperty("role")]
        public Role Role { get; set; }

        [JsonProperty("difficulty")]
        public Difficulty Difficulty { get; set; }

        [JsonProperty("displayName")]
        public string DisplayName { get; set; }

        [JsonProperty("backStory")]
        public string BackStory { get; set; }

        [JsonProperty("biography")]
        public string Biography { get; set; }

        [JsonProperty("requiredDlcIdString")]
        public string RequiredDlcIdString { get; set; }

        [JsonProperty("idName")]
        public string IdName { get; set; }

        [JsonProperty("defaultItem")]
        public string DefaultItem { get; set; }

        [JsonProperty("isAvailableInNonViolentBuild")]
        public bool IsAvailableInNonViolentBuild { get; set; }

        [JsonProperty("isAvailableInAtlantaBuild")]
        public bool IsAvailableInAtlantaBuild { get; set; }

        [JsonProperty("platformExclusiveFlag")]
        public long PlatformExclusiveFlag { get; set; }

        [JsonProperty("killerAbilities")]
        public string[] KillerAbilities { get; set; }

        [JsonProperty("gender")]
        public Gender Gender { get; set; }

        [JsonProperty("killerHeight")]
        public KillerHeight KillerHeight { get; set; }

        [JsonProperty("iconPath")]
        public string IconPath { get; set; }

        [JsonProperty("backgroundPath")]
        public string BackgroundPath { get; set; }

        [JsonProperty("slideShowDescriptions")]
        public SlideShowDescriptions SlideShowDescriptions { get; set; }
    }

    public partial class SlideShowDescriptions
    {
        [JsonProperty("overview")]
        public string Overview { get; set; }

        [JsonProperty("playStyle")]
        public string PlayStyle { get; set; }
    }

    public enum Difficulty { ECharacterDifficultyVeEasy, ECharacterDifficultyVeHard, ECharacterDifficultyVeIntermediate };

    public enum Gender { EGenderVeFemale, EGenderVeMale, EGenderVeMultiple, EGenderVeNotHuman, EGenderVeUndefined };

    public enum KillerHeight { EKillerHeightAverage, EKillerHeightShort, EKillerHeightTall };

    public enum Role { EPlayerRoleVeCamper, EPlayerRoleVeObserver, EPlayerRoleVeSlasher };

    public partial class CharacterInfoResponse
    {
        public static Dictionary<string, CharacterInfoResponse> FromJson(string json) => JsonConvert.DeserializeObject<Dictionary<string, CharacterInfoResponse>>(json, DBD_Magic.Responses.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Dictionary<string, CharacterInfoResponse> self) => JsonConvert.SerializeObject(self, DBD_Magic.Responses.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DifficultyConverter.Singleton,
                GenderConverter.Singleton,
                KillerHeightConverter.Singleton,
                RoleConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DifficultyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Difficulty) || t == typeof(Difficulty?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ECharacterDifficulty::VE_Easy":
                    return Difficulty.ECharacterDifficultyVeEasy;
                case "ECharacterDifficulty::VE_Hard":
                    return Difficulty.ECharacterDifficultyVeHard;
                case "ECharacterDifficulty::VE_Intermediate":
                    return Difficulty.ECharacterDifficultyVeIntermediate;
            }
            throw new Exception("Cannot unmarshal type Difficulty");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Difficulty)untypedValue;
            switch (value)
            {
                case Difficulty.ECharacterDifficultyVeEasy:
                    serializer.Serialize(writer, "ECharacterDifficulty::VE_Easy");
                    return;
                case Difficulty.ECharacterDifficultyVeHard:
                    serializer.Serialize(writer, "ECharacterDifficulty::VE_Hard");
                    return;
                case Difficulty.ECharacterDifficultyVeIntermediate:
                    serializer.Serialize(writer, "ECharacterDifficulty::VE_Intermediate");
                    return;
            }
            throw new Exception("Cannot marshal type Difficulty");
        }

        public static readonly DifficultyConverter Singleton = new DifficultyConverter();
    }

    internal class GenderConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Gender) || t == typeof(Gender?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EGender::VE_Female":
                    return Gender.EGenderVeFemale;
                case "EGender::VE_Male":
                    return Gender.EGenderVeMale;
                case "EGender::VE_Multiple":
                    return Gender.EGenderVeMultiple;
                case "EGender::VE_NotHuman":
                    return Gender.EGenderVeNotHuman;
                case "EGender::VE_Undefined":
                    return Gender.EGenderVeUndefined;
            }
            throw new Exception("Cannot unmarshal type Gender");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Gender)untypedValue;
            switch (value)
            {
                case Gender.EGenderVeFemale:
                    serializer.Serialize(writer, "EGender::VE_Female");
                    return;
                case Gender.EGenderVeMale:
                    serializer.Serialize(writer, "EGender::VE_Male");
                    return;
                case Gender.EGenderVeMultiple:
                    serializer.Serialize(writer, "EGender::VE_Multiple");
                    return;
                case Gender.EGenderVeNotHuman:
                    serializer.Serialize(writer, "EGender::VE_NotHuman");
                    return;
                case Gender.EGenderVeUndefined:
                    serializer.Serialize(writer, "EGender::VE_Undefined");
                    return;
            }
            throw new Exception("Cannot marshal type Gender");
        }

        public static readonly GenderConverter Singleton = new GenderConverter();
    }

    internal class KillerHeightConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(KillerHeight) || t == typeof(KillerHeight?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EKillerHeight::Average":
                    return KillerHeight.EKillerHeightAverage;
                case "EKillerHeight::Short":
                    return KillerHeight.EKillerHeightShort;
                case "EKillerHeight::Tall":
                    return KillerHeight.EKillerHeightTall;
            }
            throw new Exception("Cannot unmarshal type KillerHeight");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (KillerHeight)untypedValue;
            switch (value)
            {
                case KillerHeight.EKillerHeightAverage:
                    serializer.Serialize(writer, "EKillerHeight::Average");
                    return;
                case KillerHeight.EKillerHeightShort:
                    serializer.Serialize(writer, "EKillerHeight::Short");
                    return;
                case KillerHeight.EKillerHeightTall:
                    serializer.Serialize(writer, "EKillerHeight::Tall");
                    return;
            }
            throw new Exception("Cannot marshal type KillerHeight");
        }

        public static readonly KillerHeightConverter Singleton = new KillerHeightConverter();
    }

    internal class RoleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Role) || t == typeof(Role?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EPlayerRole::VE_Camper":
                    return Role.EPlayerRoleVeCamper;
                case "EPlayerRole::VE_Observer":
                    return Role.EPlayerRoleVeObserver;
                case "EPlayerRole::VE_Slasher":
                    return Role.EPlayerRoleVeSlasher;
            }
            throw new Exception("Cannot unmarshal type Role");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Role)untypedValue;
            switch (value)
            {
                case Role.EPlayerRoleVeCamper:
                    serializer.Serialize(writer, "EPlayerRole::VE_Camper");
                    return;
                case Role.EPlayerRoleVeObserver:
                    serializer.Serialize(writer, "EPlayerRole::VE_Observer");
                    return;
                case Role.EPlayerRoleVeSlasher:
                    serializer.Serialize(writer, "EPlayerRole::VE_Slasher");
                    return;
            }
            throw new Exception("Cannot marshal type Role");
        }

        public static readonly RoleConverter Singleton = new RoleConverter();
    }
}
